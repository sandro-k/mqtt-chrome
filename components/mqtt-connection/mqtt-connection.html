<!--polymer-->
<!--<script>-->
<!--Platform = {flags: {debug: true, log: 'bind,ready'}};-->
<!--</script>-->

<link rel="import" href="../../bower_components/polymer/polymer.html"/>
<link rel="import" href="../mqtt-subscription2/mqtt-subscription.html"/>

<script src="../../node_modules/mows/mows.js"></script>
<script src="../../bower_components/underscore/underscore.js"></script>

<polymer-element name="mqtt-connection" attributes="messages, publish, createClient, autoConnect, brokerURL, user, password, port, clientID" constructor="MqttConnection">

  <template>
    <div id="container"></div>
  </template>

  <script>

      Polymer("mqtt-connection", {

        /**
         * If `autoConnect` is set the element will try to automatically connect to the MQTT-Broker
         * note that `brokerURL` needs to be set as well
         *
         * @attribute autoConnect
         * @type boolean
         * @default false
         */
        autoConnect: false,

        /**
         * The URL of the MQTT-Broker the connection is made to.
         * Login credentials can be given inline like `ws://[USER:PASSWORD@]broker.mqttdashboard.com:[PORT]`
         * or set via `user`, `password` and `port`
         *
         * @attribute brokerURL
         * @type string
         * @default ''
         *
         */
        brokerURL: '',

        /**
         * The username that will be used to authenticate with the MQTT-Broker
         *
         * @attribute user
         * @type string
         * @default ''
         */
        user: '',

        /**
         * The password that will be used to authenticate the `user` at the MQTT-Broker
         *
         * @attribute password
         * @type string
         * @default ''
         */
        password: '',

        /**
         * The port the connection is made with
         *
         * @attribute port
         * @type number [1..2^16-1]
         */
         port: 1883,

        /**
         * A unique client ID to identify the MQTT-client at the broker (23 byte string)
         * @default ''
         */

        clientID: '',


        /**
         * Use a clean session
         *
         */
        cleanSession: true,

        /**
         * Use SSL
         */
        ssl: false,

        keepAlive: 120,

        observe: {
//          'messages.changed': 'messagesChanged'
        },

        created: function () {
          console.log("created");

          this.that = this;
          this.messages = {};
//          this.messages.changed = false;
          this.client = {};
          this.that = {};
          this.subscriptions = {};

        },
        ready: function () {
          console.log("ready");
          this.content = this.$.container;

        },

        /**
         * Subscribes to a MQTT-topic
         *
         * @param {String} topic the subscription is created on
         * @param {Object} opt_options (optional) additional options that effect the subscription type
         * @param opt_target (optional) the target element the subscription should be appended to
         */
        subscribe: function (topic, opt_options, opt_target) {
          console.debug("Subscribing to: \"%s\'", topic);

          if (this.subscriptions[topic] !== undefined) {
            console.error("Subscription to %s already exists", topic);
            return;
          }

          // actually subscribing to the topic
          this.client.subscribe(topic);

          // creating the View
          this.subscriptions[topic] = new MqttSubscription();
          // start listening to view events
          var self = this;
          this.subscriptions[topic].addEventListener("unsubscribe", function (e, detail, sender) {
            self.asyncFire('toast', {text: "test"});
            console.log(self.unsubscribe);
            self.unsubscribe("presence")
          });

          this.subscriptions[topic].addEventListener("saveSub", function (e, detail, sender) {
            console.log("Hi");
            console.log(this);
          });

          this.subscriptions[topic].addEventListener("pause", function (e, detail, sender) {
            console.log("Hi");
            console.log(this);
          });

          // setting the view topic
          this.subscriptions[topic].topic = topic;



          // adding MqttSubscription to DOM
          if (opt_target !== undefined) {
            this.subscriptions[topic].target = opt_target;
            // if an extra targetID is supplied the view is appended to that
//            document.getElementById(opt_target).appendChild(this.subscriptions[topic]);
              opt_target.appendChild(this.subscriptions[topic]);
          } else {
            this.subscriptions[topic].target = this.content;
            // otherwise the subscription view will be appended to the content area
            this.content.appendChild(this.subscriptions[topic]);
          }

          console.log(this.subscriptions[topic]);
        },

        unsubscribe: function (topic) {

          console.log(this);

          if (this.subscriptions[topic] !== undefined) {
            // unsubscribe
            this.client.unsubscribe(topic);

            // remove from DOM
            this.subscriptions[topic].target.removeChild(this.subscriptions[topic]);

            // delete reference
            delete this.subscriptions[topic];




          } else {
            console.error("Subscription to %s doesn't exists, can't unsubscribe", topic);
          }
        },

        unsubscribeEvent: function (e, detail, sender) {
          // we will receive `unsubscribeEvent` from `mqtt-subscription` elements
          console.debug("unsubscribeEvent");
          //todo check if connectionID is the same as this ones
          this.unsubscribe(e.detail.topic);

        },

        publish: function (topic, message) {
          this.client.publish(topic, message);
        },

        onMessage: function (topic, payload, object) {
          console.log("onMessage: %s", payload);

          object.timestamp = Date.now();


          // add message to viewModel
          this.subscriptions[topic].addMessage(object);

//          this.messages2.push(object);
//
//          if (this.messages.hasOwnProperty(topic)) {
//            this.messages[topic].push(object);
//          } else {
//            this.messages[topic] = [object];
//          }

//          this.messages.changed = !this.messages.changed;

        },

        messagesChanged: function () {
          console.log("Messages: %s", JSON.stringify(this.messages));
        },


        domReady: function () {
          console.log("domReady");
          // at this point all attributes of the element
          // should be loaded and we are save to act on settings

        },

        end: function () {
          this.client.end();
        },

        createClient: function (serverUrl) {
          var that = this;
          this.client = mows.createClient(serverUrl);
          // pass an optional 'ws://localhost:port' here.
          // save reference to this element to reroute messages
          var self = this;
          this.client.on('message', function (topic, message, object) {
            console.log(arguments);
            self.onMessage(topic, message, object);
          });
        }

      });
  </script>
</polymer-element>