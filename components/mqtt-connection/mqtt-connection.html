<!--polymer-->
<!--<script>-->
<!--Platform = {flags: {debug: true, log: 'bind,ready'}};-->
<!--</script>-->

<link rel="import" href="../../bower_components/polymer/polymer.html"/>
<link rel="import" href="../mqtt-subscription2/mqtt-subscription.html"/>

<script src="../../node_modules/mows/mows.js"></script>
<script src="../../bower_components/underscore/underscore.js"></script>

<polymer-element name="mqtt-connection" attributes="" constructor="MqttConnection">

  <template>
    <div id="container"></div>
  </template>

  <script>

      Polymer("mqtt-connection", {

        publish: {
          /**
           * If `autoConnect` is set the element will try to automatically connect to the MQTT-Broker
           * note that `hostname` needs to be set as well
           *
           * @attribute autoConnect
           * @type boolean
           * @default false
           */
          autoConnect: false,

          /**
           * The URL of the MQTT-Broker the connection is made to.
           * Login credentials can be given inline like `ws://[USER:PASSWORD@]broker.mqttdashboard.com:[PORT]`
           * or set via `user`, `password` and `port`
           *
           * @attribute hostname
           * @type string
           * @default ''
           *
           */
          hostname: '',


          /**
           * The username that is user to authenticate the connection with
           * @attribute username
           * @type string
           * @default ''
           */
          username: '',



          /**
           * The password that will be used to authenticate the `user` at the MQTT-Broker
           *
           * @attribute password
           * @type string
           * @default ''
           */
          password: '',


          /**
           *
           *
           */
          passwordHashFunction: true,


          /**
           * The port the connection is made with
           * @attibute hostPort
           * @type number [1..2^16-1]
           * @default 1883
           */
          hostPort: 1883,




          /**
           * Start a clean session
           * @attribute cleanSession
           * @type boolean
           * @default true
           */
          cleanSession: true,


          /**
           * Use SSL for to encrypt the connection
           * @attrubute useSSL
           * @type boolean
           * @default false
           */
          useSSL: false,


          /**
           * Seconds that the connection is kept alive in seconds
           * @attribute keepAlive
           * @type integer
           * @default 120
           */
          keepAlive: 120,

          /**
           * The topic the last will will be published at
           * @attribute lastWillTopic
           * @type string
           * @default ''
           */
          lastWillTopic: '',

          /**
           * The last will message that will be published at `lastWillTopic`
           * @attribute lastWillMessage
           * @type  string
           * @default ''
           */
          lastWillMessage: '',

          /**
           * The QoS the last will will be published with
           * @attribute lastWillQoS
           * @type integer (0|1|2)
           * @default 0
           */
          lastWillQoS: 0,


          /**
           * @attribute lastWillRetained
           * @type boolean
           * @default false
           */
          lastWillRetained: false,


          /**
           * @attribute autoConnect
           * @type boolean
           * @default false
           */
          autoConnect: true,


          /**
           * A flag that indicates whether or not the connection is connected
           * @attribute connected
           * @type boolean
           * @default false
           */
          connected: null,


          /**
           * A object that holds all `mqtt-subscription` elements each subscription is stored at subscriptions.topic
           * @attribute subscriptions
           * @type object
           * @default {}
           */
          subscriptions: {},


          /**
           * A human readable name for the connection
           * @attribute connectionName
           * @type string
           * @default ''
           */
          connectionName: '',


          /**
           * A ID to identify the connection
           * @attribute connectionID
           * @type string
           * @default ''
           */
          connectionID: '',

          /**
           * A human readable name for the connection
           * @attribute connectionName
           * @type string
           * @default ''
           */
          connectionName: '',


          /**
           * The base color for the connection
           * @attribute connectionColor
           * @type string (hex)
           * @default ''
           */
          connectionColor: '',


          /**
           * The color shema of this connection
           * @attribute connectionColors
           * @type array [0..9]
           * @default []
           */
          connectionColors: [],


          /**
           * A unique client ID to identify the client at the broker
           * @attribute clientId
           * @type string
           * @default ''
           */
          clientId: '',


          /**
           * @attribute autoConnect
           * @type boolean
           * @default false
           */
          autoConnect: false,

        },

        observe: {
          'client.connected': 'connectionChanged'
        },

        created: function () {
          console.log("created");
          this.messages = {};
          this.subscriptions = {};
          this.subscriptions.keys = [];
          this.connectionColors = [];

        },
        ready: function () {
          console.log("ready");
          this.content = this.$.container;

        },

        /**
         * Subscribes to a MQTT-topic
         *
         * @param {String} topic the subscription is created on
         * @param {Object} opt_options (optional) additional options that effect the subscription type
         * @param opt_target (optional) the target element the subscription should be appended to
         */
        subscribe: function (topic, opt_options, opt_target, opt_callback) {
          console.debug("Subscribing to: \"%s\'", topic);

          var alreadyInDom = false;
          if (this.subscriptions[topic] !== undefined) {
            console.error("Subscription to %s already exists", topic);
            alreadyInDom = true;
//            return;
          }

          // actually subscribing to the topic
          this.client.subscribe(topic, opt_options, opt_callback);

          if (!alreadyInDom) {
            // creating the View
            this.subscriptions[topic] = new MqttSubscription();
            this.subscriptions[topic].connectionID = this.connectionID;
            this.subscriptions.keys.push(topic);
          }

          // start listening to view events
          var self = this;
          this.subscriptions[topic].addEventListener("unsubscribe", function (e, detail, sender) {
            self.asyncFire('toast', {text: "Removed subscription to "+ e.detail.topic});
//            console.log(self.unsubscribe);
            // TODO put real topic into unsubscribe
            self.unsubscribe(e.detail.topic)
          });

          this.subscriptions[topic].addEventListener("saveSub", function (e, detail, sender) {
            // TODO(sandro-k) handel event
            console.log(this);
          });

          this.subscriptions[topic].addEventListener("pause", function (e, detail, sender) {
            // TODO(sandro-k) handel event
            console.log(this);
          });

          // setting the view topic
          this.subscriptions[topic].topic = topic;


          if (!alreadyInDom) {
            // adding MqttSubscription to DOM
            if (opt_target !== undefined) {
              this.subscriptions[topic].target = opt_target;
              // if an extra targetID is supplied the view is appended to that
//            document.getElementById(opt_target).appendChild(this.subscriptions[topic]);
              opt_target.appendChild(this.subscriptions[topic]);
            } else {
              this.subscriptions[topic].target = this.content;
              // otherwise the subscription view will be appended to the content area
              this.content.appendChild(this.subscriptions[topic]);
            }
          }


          console.log(this.subscriptions[topic]);
        },

        reSubscribe: function (topic) {
          console.debug("Subscribing to: \"%s\'", topic);

          var alreadyInDom = false;
          if (this.subscriptions[topic] == undefined) {
            console.error("Can not resubscribe to %s, subscription doesn't exist ", topic);
            return;
          }

          // actually subscribing to the topic
          this.client.subscribe(topic);


          // start listening to view events
          var self = this;
          this.subscriptions[topic].addEventListener("unsubscribe", function (e, detail, sender) {
            self.asyncFire('toast', {text: "Removed subscription to "+ e.detail.topic});
//            console.log(self.unsubscribe);
            // TODO put real topic into unsubscribe
            console.log("BLUB");
            self.unsubscribe("presence")
          });

          this.subscriptions[topic].addEventListener("saveSub", function (e, detail, sender) {
            // TODO(sandro-k) handel event
            console.log(this);
          });

          this.subscriptions[topic].addEventListener("pause", function (e, detail, sender) {
            // TODO(sandro-k) handel event
            console.log(this);
          });

          // setting the view topic
          this.subscriptions[topic].topic = topic;





          console.log(this.subscriptions[topic]);
        },

        unsubscribe: function (topic) {

          console.log(this);

          if (this.subscriptions[topic] !== undefined) {
            // unsubscribe
            this.client.unsubscribe(topic);

            // remove from DOM
            this.subscriptions[topic].removeFromDOM();
//            this.subscriptions[topic].target.removeChild(this.subscriptions[topic]);

            // delete reference
            delete this.subscriptions[topic];

            this.subscriptions.keys

            this.subscriptions.keys = _.without(this.subscriptions.keys, topic);




          } else {
//            console.error("Subscription to %s doesn't exists, can't unsubscribe", topic);
          }
        },

        unsubscribeEvent: function (e, detail, sender) {
          // we will receive `unsubscribeEvent` from `mqtt-subscription` elements
          console.debug("unsubscribeEvent");
          //todo check if connectionID is the same as this ones
          this.unsubscribe(e.detail.topic);

        },

        mqttPublish: function (topic, message, opt_options, opt_callback) {
          console.log(message);
          this.client.publish(topic, message, opt_options, opt_callback);

        },

        onMessage: function (topic, payload, object) {
//          console.log("onMessage %s: %s", topic, payload);
          console.log(object);

          // add a timestamp to the message as it has none
          object.timestamp = Date.now();
          object.connectionName = this.connectionName;
          object.connectionID =   this.connectionID;
          if (this.subscriptions[topic]) {
            // add message to viewModel
            this.subscriptions[topic].addMessage(object);
          } else {
            var self = this;
            _.each(_.keys(this.subscriptions), function (key) {
                if(key.indexOf('+') > -1){
                  var sub = key.substring(0,key.indexOf('+'));


                  if (topic.indexOf(sub) > -1) {
                    // need to check if last char is '/' is zero or one and last char is '/'
                    // if the topic is aa/bb and the subscription is to aa/+
                    // topic.substring(key.indexOf('+')) will be bb and match(/\//g) will count the
                    // occurrences of '/'
                    // if no '/' is present [] will assure that the .length attrubte is valid
                    var substring = topic.substring(key.indexOf('+'));
                    var count = (substring.match(/\//g) || [] ).length;
                    if (count == 0){
                      self.subscriptions[key].addMessage(object);
                    } else if (count == 1 && (substring.slice(-1) == '/' ) ){
                      self.subscriptions[key].addMessage(object);
                    }


                  }
                } else if (key.indexOf('#') > -1){
                  var sub = key.substring(0,key.indexOf('#'));

                  if (topic.indexOf(sub) > -1) {
                    self.subscriptions[key].addMessage(object);
                  }
                } else {
                  console.error("Received message to subscription we don't have: %s, %s, %s", topic, payload, object)
                }
            });
          }
        },

        messagesChanged: function () {
//          console.log("Messages: %s", JSON.stringify(this.messages));
        },


        domReady: function () {
//          console.log("domReady");
          // at this point all attributes of the element
          // should be loaded and we are save to act on settings

        },

        end: function () {
          this.client.end();
        },

        connect: function () {
             if (!this.client) {
               this.createClient();
             } else {
               this.client.connect();
             }
        },

        disconnect: function () {
          if (this.client) {
            this.client.end();
//            console.log(this.client);
          }
        },

        reconnect: function () {
          // need to use a private method to reconnect otherwise we have to recreate the connection
          this.client._reconnect()
          var self = this;
          _.each(this.subscriptions, function(item) {
            self.reSubscribe( item.topic );
          });

        },

        logPublishedValues: function() {
          for (var property in this.publish) {
            console.log("%s: %s", property, this[property]);
          }

        },

        createClient: function () {


          var options = { clean: true,
            protocolId: "MQIsdp",
            protocolVersion: 3,
            keepalive: this.keepAlive,
            clientId: this.clientId,
            will: {
              topic: this.lastWillTopic,
              payload: this.lastWillMessage,
              qos: this.lastWillQoS,
              retain: this.lastWillRetained
            },
            encoding: "utf8",
            clean: this.clean
          };

          //reconnectPeriod: 1000

          if (this.username != '' && this.password != '') {
            options.username = this.username;
            options.password = this.password;
          }

//          this.logPublishedValues();

          this.hostPort = parseInt(this.hostPort);
          this.client = mows.createClient(this.hostPort, this.hostname, options);

          this.client.on('connect', function(){
            console.log('Client Connected');
          });

          this.client.on('error', function(e){
            console.log('Client Error:', e);
          });


//          console.log("ConnecteD: %s", this.client.connected)

          this.connected = this.client.connected;
//          console.debug( this.client );
          // pass an optional 'ws://localhost:port' here.
          // save reference to this element to reroute messages
          var self = this;

          this.client.on('message', function (topic, message, object) {
//            console.log(arguments);
            self.onMessage(topic, message, object);
          });

        },


        /**
         * ##### WATCHES #####
         */

        connectionChanged: function (oldValue, newValue){
          console.log("Old: %s, new: %s", oldValue, newValue);
          this.connected = newValue;



          if (newValue && (oldValue !== undefined)) {
            this.asyncFire("toast", {text: "Connection established to: "+ this.hostname, status: "ok"});
          } else if (oldValue !== undefined) {
            this.asyncFire("toast", {text: "Connection to: "+ this.hostname + "failed", status: "error"});
          }

        },

        connectionColorChanged: function() {
          this.connectionColors[0] = this.connectionColor;

          for (var i = 1; i< 10; i++) {
            this.connectionColors[i] = this.shadeColor2(this.connectionColor, 0.10*i);
//            console.log(0.10*i);
          }

//          console.log(this.connectionColors);
        },

        updateConnection: function(conValues) {
//          this.connectionColor = conValues.connectionColor;
          console.log(conValues);

          for (var property in this.publish) {
            if (conValues[property]) {
              this[property] = conValues[property];
            }
          }

        },

        /**
         * ##### HELPER FUNCTIONS #####
         */

        /**
         * A helper function to lighten or darken colors
         * from (http://css-tricks.com/snippets/javascript/lighten-darken-color/)
         * @param col the color without or without the datsh (#)
         * @param amt how mutch the color should be lightend or darkend [-100, +100]
         * @returns {string} the color in hex with the dash (#)
         */
        lightenDarkenColor: function (col, amt) {

        var usePound = true;

        if (col[0] == "#") {
          col = col.slice(1);
          usePound = true;
        }

        var num = parseInt(col,16);

        var r = (num >> 16) + amt;

        if (r > 255) r = 255;
        else if  (r < 0) r = 0;

        var b = ((num >> 8) & 0x00FF) + amt;

        if (b > 255) b = 255;
        else if  (b < 0) b = 0;

        var g = (num & 0x0000FF) + amt;

        if (g > 255) g = 255;
        else if (g < 0) g = 0;

          //        return (usePound?"#":"") + (g | (b << 8) | (r << 16)).toString(16);
        return (usePound?"#":"") + String("000000" + (g | (b << 8) | (r << 16)).toString(16)).slice(-6);
      },

      shadeColor2: function (color, percent) {
        var f=parseInt(color.slice(1),16),t=percent<0?0:255,p=percent<0?percent*-1:percent,R=f>>16,G=f>>8&0x00FF,B=f&0x0000FF;
        return "#"+(0x1000000+(Math.round((t-R)*p)+R)*0x10000+(Math.round((t-G)*p)+G)*0x100+(Math.round((t-B)*p)+B)).toString(16).slice(1);
      }


      });
  </script>
</polymer-element>