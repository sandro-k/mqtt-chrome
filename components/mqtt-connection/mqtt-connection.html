<!--polymer-->
<!--<script>-->
<!--Platform = {flags: {debug: true, log: 'bind,ready'}};-->
<!--</script>-->

<link rel="import" href="../../bower_components/polymer/polymer.html"/>
<link rel="import" href="../mqtt-subscription2/mqtt-subscription.html"/>

<script src="../../node_modules/mows/mows.js"></script>
<script src="../../bower_components/underscore/underscore.js"></script>

<polymer-element name="mqtt-connection" attributes="messages, publish, createClient, autoConnect, hostname, user, password, port, clientID" constructor="MqttConnection">

  <template>
    <div id="container"></div>
  </template>

  <script>

      Polymer("mqtt-connection", {

        publish: {
          /**
           * If `autoConnect` is set the element will try to automatically connect to the MQTT-Broker
           * note that `hostname` needs to be set as well
           *
           * @attribute autoConnect
           * @type boolean
           * @default false
           */
          autoConnect: false,

          /**
           * The URL of the MQTT-Broker the connection is made to.
           * Login credentials can be given inline like `ws://[USER:PASSWORD@]broker.mqttdashboard.com:[PORT]`
           * or set via `user`, `password` and `port`
           *
           * @attribute hostname
           * @type string
           * @default ''
           *
           */
          hostname: '',

          /**
           * The username that will be used to authenticate with the MQTT-Broker
           *
           * @attribute user
           * @type string
           * @default ''
           */
          user: '',

          /**
           * The password that will be used to authenticate the `user` at the MQTT-Broker
           *
           * @attribute password
           * @type string
           * @default ''
           */
          password: '',

          /**
           * The port the connection is made with
           *
           * @attribute port
           * @type number [1..2^16-1]
           */
          port: 1883,

          /**
           * A unique client ID to identify the MQTT-client at the broker (23 byte string)
           * @default ''
           */

          clientID: '',


          /**
           * Use a clean session
           *
           */
          cleanSession: true,

          /**
           * Use SSL
           */
          ssl: false,

          keepAlive: 120,

          connected: false,

          subscriptions: [],

          name: '',

          connectionID: '55',
        },

        observe: {
          'client.connected': 'connectionChanged'
        },

        created: function () {
          console.log("created");

          this.that = this;
          this.messages = {};
          this.that = {};
          this.subscriptions = {};
          this.subscriptions.keys = [];

        },
        ready: function () {
          console.log("ready");
          this.content = this.$.container;

        },

        /**
         * Subscribes to a MQTT-topic
         *
         * @param {String} topic the subscription is created on
         * @param {Object} opt_options (optional) additional options that effect the subscription type
         * @param opt_target (optional) the target element the subscription should be appended to
         */
        subscribe: function (topic, opt_options, opt_target) {
          console.debug("Subscribing to: \"%s\'", topic);

          var alreadyInDom = false;
          if (this.subscriptions[topic] !== undefined) {
            console.error("Subscription to %s already exists", topic);
            alreadyInDom = true;
//            return;
          }

          // actually subscribing to the topic
          this.client.subscribe(topic);

          if (!alreadyInDom) {
            // creating the View
            this.subscriptions[topic] = new MqttSubscription();
            this.subscriptions.keys.push(topic);
          }

          // start listening to view events
          var self = this;
          this.subscriptions[topic].addEventListener("unsubscribe", function (e, detail, sender) {
            self.asyncFire('toast', {text: "Removed subscription to "+ e.detail.topic});
//            console.log(self.unsubscribe);
            // TODO put real topic into unsubscribe
            console.log("BLUB");
            self.unsubscribe("presence")
          });

          this.subscriptions[topic].addEventListener("saveSub", function (e, detail, sender) {
            // TODO(sandro-k) handel event
            console.log(this);
          });

          this.subscriptions[topic].addEventListener("pause", function (e, detail, sender) {
            // TODO(sandro-k) handel event
            console.log(this);
          });

          // setting the view topic
          this.subscriptions[topic].topic = topic;


          if (!alreadyInDom) {
            // adding MqttSubscription to DOM
            if (opt_target !== undefined) {
              this.subscriptions[topic].target = opt_target;
              // if an extra targetID is supplied the view is appended to that
//            document.getElementById(opt_target).appendChild(this.subscriptions[topic]);
              opt_target.appendChild(this.subscriptions[topic]);
            } else {
              this.subscriptions[topic].target = this.content;
              // otherwise the subscription view will be appended to the content area
              this.content.appendChild(this.subscriptions[topic]);
            }
          }


          console.log(this.subscriptions[topic]);
        },

        reSubscribe: function (topic) {
          console.debug("Subscribing to: \"%s\'", topic);

          var alreadyInDom = false;
          if (this.subscriptions[topic] == undefined) {
            console.error("Can not resubscribe to %s, subscription doesn't exist ", topic);
            return;
          }

          // actually subscribing to the topic
          this.client.subscribe(topic);


          // start listening to view events
          var self = this;
          this.subscriptions[topic].addEventListener("unsubscribe", function (e, detail, sender) {
            self.asyncFire('toast', {text: "Removed subscription to "+ e.detail.topic});
//            console.log(self.unsubscribe);
            // TODO put real topic into unsubscribe
            console.log("BLUB");
            self.unsubscribe("presence")
          });

          this.subscriptions[topic].addEventListener("saveSub", function (e, detail, sender) {
            // TODO(sandro-k) handel event
            console.log(this);
          });

          this.subscriptions[topic].addEventListener("pause", function (e, detail, sender) {
            // TODO(sandro-k) handel event
            console.log(this);
          });

          // setting the view topic
          this.subscriptions[topic].topic = topic;





          console.log(this.subscriptions[topic]);
        },

        unsubscribe: function (topic) {

          console.log(this);

          if (this.subscriptions[topic] !== undefined) {
            // unsubscribe
            this.client.unsubscribe(topic);

            // remove from DOM
            this.subscriptions[topic].removeFromDOM();
//            this.subscriptions[topic].target.removeChild(this.subscriptions[topic]);

            // delete reference
            delete this.subscriptions[topic];




          } else {
            console.error("Subscription to %s doesn't exists, can't unsubscribe", topic);
          }
        },

        unsubscribeEvent: function (e, detail, sender) {
          // we will receive `unsubscribeEvent` from `mqtt-subscription` elements
          console.debug("unsubscribeEvent");
          //todo check if connectionID is the same as this ones
          this.unsubscribe(e.detail.topic);

        },

        publish: function (topic, message) {
          this.client.publish(topic, message);
        },

        onMessage: function (topic, payload, object) {
          console.log("onMessage %s: %s", topic, payload);

          // add a timestamp to the message as it has none
          object.timestamp = Date.now();
          if (this.subscriptions[topic]) {
            // add message to viewModel
            this.subscriptions[topic].addMessage(object);
          } else {
            var self = this;
            _.each(_.keys(this.subscriptions), function (key) {
                if(key.indexOf('+') > -1){
                  var sub = key.substring(0,key.indexOf('+'));
                  console.log(sub);
                  console.log(key);
                  console.log(topic);

                  if (topic.indexOf(sub) > -1) {
                    // need to check if last char is '/' is zero or one and last char is '/'
                    // if the topic is aa/bb and the subscription is to aa/+
                    // topic.substring(key.indexOf('+')) will be bb and match(/\//g) will count the
                    // occurrences of '/'
                    // if no '/' is present [] will assure that the .length attrubte is valid
                    var substring = topic.substring(key.indexOf('+'));
                    var count = (substring.match(/\//g) || [] ).length;
                    if (count == 0){
                      self.subscriptions[key].addMessage(object);
                    } else if (count == 1 && (substring.slice(-1) == '/' ) ){
                      self.subscriptions[key].addMessage(object);
                    }


                  }
                } else if (key.indexOf('#') > -1){
                  var sub = key.substring(0,key.indexOf('#'));
                  console.log(sub);
                  console.log(key);
                  console.log(topic);
                  if (topic.indexOf(sub) > -1) {
                    self.subscriptions[key].addMessage(object);
                  }
                } else {
                  console.error("Received message to subscription we don't have: %s, %s, %s", topic, payload, object)
                }
            });
          }
        },

        messagesChanged: function () {
          console.log("Messages: %s", JSON.stringify(this.messages));
        },


        domReady: function () {
          console.log("domReady");
          // at this point all attributes of the element
          // should be loaded and we are save to act on settings

        },

        end: function () {
          this.client.end();
        },

        connect: function () {
             if (!this.client) {
               this.createClient();
             } else {
               this.client.connect();
             }
        },

        disconnect: function () {
          if (this.client) {
//            this.client.disconnect();
            this.client.end();
            this.client.end();
            console.log(this.client);
          }
        },

        reconnect: function () {
          // need to use a private method to reconnect otherwise we have to recreate the connection
          this.client._reconnect()
          var self = this;
          _.each(this.subscriptions, function(item) {
            self.reSubscribe( item.topic );
          });

        },

        createClient: function () {
          var that = this;

          var options = { clean: true,
            encoding: "utf8",
            keepalive: 60,
            protocolId: "MQIsdp",
            protocolVersion: 3,
            reconnectPeriod: 1000};

          this.client = mows.createClient(this.port, this.hostname, options);

          console.log("ConnecteD: %s", this.client.connected)

          this.connected = this.client.connected;
          console.debug( this.client );
          // pass an optional 'ws://localhost:port' here.
          // save reference to this element to reroute messages
          var self = this;
          this.client.on('message', function (topic, message, object) {
            console.log(arguments);
            self.onMessage(topic, message, object);
          });

          self.asyncFire("toast", {text: "Connection established to: "+ this.hostname, status: "ok"});
        },


        /**
         * ##### WATCHES ####
         */

        connectionChanged: function (oldValue, newValue){
          console.log("Old: %s, new: %s", oldValue, newValue);
          this.connected = newValue;
        }


      });
  </script>
</polymer-element>